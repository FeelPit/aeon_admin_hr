{"ast":null,"code":"let r;\nfunction y(e, c) {\n  r && r.set(e, c) || c();\n}\nfunction m(e) {\n  if (r) return e();\n  r = /* @__PURE__ */new Map();\n  try {\n    e();\n  } finally {\n    r.forEach(c => c()), r = void 0;\n  }\n}\n// @__NO_SIDE_EFFECTS__\nfunction S(e, c) {\n  c || (c = {});\n  const g = c.equals || Object.is;\n  let u = [],\n    s = e;\n  const i = t => {\n    if (!g(s, t)) {\n      const l = s;\n      s = t, y(o, () => {\n        [...u].forEach(_ref => {\n          let [f, d] = _ref;\n          f(t, l), d && n(f, !0);\n        });\n      });\n    }\n  };\n  function a(t) {\n    const l = typeof t != \"object\" ? {\n      once: t\n    } : t;\n    return {\n      once: l.once || !1,\n      signal: l.signal || !1\n    };\n  }\n  const n = (t, l) => {\n      const f = a(l),\n        d = u.findIndex(_ref2 => {\n          let [h, p] = _ref2;\n          return h === t && p.once === f.once && p.signal === f.signal;\n        });\n      d >= 0 && u.splice(d, 1);\n    },\n    o = Object.assign(function () {\n      return j(o), s;\n    }, {\n      destroy() {\n        u = [];\n      },\n      set: i,\n      reset() {\n        i(e);\n      },\n      sub(t, l) {\n        return u.push([t, a(l)]), () => n(t, l);\n      },\n      unsub: n,\n      unsubAll() {\n        u = u.filter(t => t[1].signal);\n      }\n    });\n  return o;\n}\nconst b = [];\nfunction j(e) {\n  b.length && b[b.length - 1].add(e);\n}\n// @__NO_SIDE_EFFECTS__\nfunction x(e, c) {\n  let g = /* @__PURE__ */new Set(),\n    u;\n  function s() {\n    return u || (u = /* @__PURE__ */S(a(), c));\n  }\n  function i() {\n    s().set(a());\n  }\n  function a() {\n    g.forEach(t => {\n      t.unsub(i, {\n        signal: !0\n      });\n    });\n    const n = /* @__PURE__ */new Set();\n    let o;\n    b.push(n);\n    try {\n      o = e();\n    } finally {\n      b.pop();\n    }\n    return n.forEach(t => {\n      t.sub(i, {\n        signal: !0\n      });\n    }), g = n, o;\n  }\n  return Object.assign(function () {\n    return s()();\n  }, {\n    destroy() {\n      s().destroy();\n    },\n    sub() {\n      return s().sub(...arguments);\n    },\n    unsub() {\n      s().unsub(...arguments);\n    },\n    unsubAll() {\n      s().unsubAll(...arguments);\n    }\n  });\n}\nexport { m as batch, x as computed, S as signal };","map":{"version":3,"names":["r","y","e","c","set","m","Map","forEach","S","g","equals","Object","is","u","s","i","t","l","o","_ref","f","d","n","a","once","signal","unsub","findIndex","_ref2","h","p","splice","assign","j","destroy","reset","sub","push","unsubAll","filter","b","length","add","x","Set","pop","arguments"],"sources":["/Users/antonver/aeon_admin_hr-1/frontend/node_modules/@telegram-apps/signals/src/batch.ts","/Users/antonver/aeon_admin_hr-1/frontend/node_modules/@telegram-apps/signals/src/signal.ts","/Users/antonver/aeon_admin_hr-1/frontend/node_modules/@telegram-apps/signals/src/computed.ts"],"sourcesContent":["import { Signal } from './signal.js';\n\nlet callbacks: Map<Signal<any>, () => void> | undefined;\n\nexport function runInBatchMode(signal: Signal<any>, fn: () => void): void {\n  callbacks && callbacks.set(signal, fn) || fn();\n}\n\n/**\n * Runs the specified function in the batch mode.\n *\n * It makes all signals' subscribers to be called only after signals changes inside the specified\n * function were applied.\n * @param fn - function to run in the batch mode.\n * @example\n * const a = signal(1);\n * const b = signal(1);\n * const c = computed(() => a() + b());\n *\n * function subscriber(value) {\n *   console.log(value);\n * }\n *\n * c.sub(subscriber);\n *\n * batch(() => {\n *   a.set(2);\n *   a.set(3);\n *   b.set(2);\n *   b.set(3);\n * });\n *\n * // Despite the fact that we called signals setters four times, the `subscriber` function will\n * // be called only once. Removing the `batch` function usage will lead to calling the `subscriber`\n * // function four times.\n */\nexport function batch(fn: () => void): void {\n  // There could be a case when a batch is called inside other batches.\n  // In this case, we should just ignore the current call.\n  if (callbacks) {\n    return fn();\n  }\n  callbacks = new Map();\n\n  try {\n    fn();\n  } finally {\n    callbacks.forEach(cb => cb());\n    callbacks = undefined;\n    // TODO: What if something went wrong in fn or its callbacks?\n  }\n}\n","import { collectSignal } from './computed.js';\nimport { runInBatchMode } from './batch.js';\n\nexport type SubscribeListenerFn<T> = (current: T, previous: T) => void;\nexport type RemoveListenerFn = () => void;\n\nexport interface SignalOptions<T> {\n  /**\n   * Previous and next values comparator.\n   *\n   * This function is used during the actual and incoming values comparison in the `set` method.\n   * If values are considered the same, no subscribers will be called.\n   *\n   * @default Object.is\n   * @param current - the actual value.\n   * @param next - an incoming value.\n   * @returns True if values are considered the same.\n   */\n  equals?: (current: T, next: T) => boolean;\n}\n\nexport interface SubOptions {\n  /**\n   * Should the listener be called only once.\n   */\n  once?: boolean;\n  /**\n   * True if the subscriber was added by another signal.\n   */\n  signal?: boolean;\n}\n\nexport interface Signal<T> {\n  /**\n   * @returns An underlying signal value.\n   */\n  (): T;\n  /**\n   * Destroys the signal removing all bound listeners.\n   *\n   * We usually use this method when the signal is not needed anymore.\n   *\n   * Take note that as long as call of this method removes all bound listeners, computed signals\n   * based on the current one will stop listening to its changes, possibly making it work\n   * improperly.\n   */\n  destroy: () => void;\n  /**\n   * Resets the signal to its initial value.\n   */\n  reset: () => void;\n  /**\n   * Updates the signal notifying all subscribers about changes.\n   * @param value - value to set.\n   */\n  set: (value: T) => void;\n  /**\n   * Adds a new listener, tracking the signal changes.\n   * @param fn - event listener.\n   * @param onceOrOptions - was this listener added for a single call, or additional\n   * options.\n   * @returns A function to remove the bound listener.\n   */\n  sub: (fn: SubscribeListenerFn<T>, onceOrOptions?: boolean | SubOptions) => RemoveListenerFn;\n  /**\n   * Removes a listener, tracking the signal changes.\n   * @param fn - event listener.\n   * @param onceOrOptions - was this listener added for a single call, or additional\n   * options. Default: false\n   */\n  unsub: (fn: SubscribeListenerFn<T>, onceOrOptions?: boolean | SubOptions) => void;\n  /**\n   * Remove all non-signal listeners.\n   */\n  unsubAll: () => void;\n}\n\n/**\n * Creates a new signal with initial value.\n * @param initialValue - initial value.\n * @param options - additional options.\n */\nexport function signal<T>(\n  initialValue: T,\n  options?: SignalOptions<T>,\n): Signal<T>;\n\n/**\n * Creates a new signal without initial value.\n * @param initialValue\n * @param options - additional options.\n */\nexport function signal<T>(\n  initialValue?: T,\n  options?: SignalOptions<T | undefined>,\n): Signal<T | undefined>;\n\n// #__NO_SIDE_EFFECTS__\nexport function signal<T>(\n  initialValue?: T,\n  options?: SignalOptions<T | undefined>,\n): Signal<T | undefined> {\n  type CurrentSignal = Signal<T | undefined>;\n\n  options ||= {};\n  const equals = options.equals || Object.is;\n\n  let listeners: [\n    listener: SubscribeListenerFn<T | undefined>,\n    options: Required<SubOptions>\n  ][] = [];\n  let value: ReturnType<CurrentSignal> = initialValue;\n\n  const set: CurrentSignal['set'] = v => {\n    if (!equals(value, v)) {\n      const prev = value;\n      value = v;\n\n      // We are making a copy of listeners as long as they may mutate the listeners' array,\n      // leading to an unexpected behavior.\n      //\n      // We want the setter to make sure that all listeners will be called in predefined\n      // order within a single update frame.\n      runInBatchMode(s, () => {\n        [...listeners].forEach(([fn, once]) => {\n          fn(v, prev);\n\n          // Remove \"once\" listeners.\n          if (once) {\n            unsub(fn, true);\n          }\n        });\n      });\n    }\n  };\n\n  function formatSubOptions(onceOrOptions: boolean | SubOptions | undefined): Required<SubOptions> {\n    const options = typeof onceOrOptions !== 'object'\n      ? { once: onceOrOptions }\n      : onceOrOptions;\n    return {\n      once: options.once || false,\n      signal: options.signal || false,\n    };\n  }\n\n  const unsub: CurrentSignal['unsub'] = (fn, onceOrOptions) => {\n    const options = formatSubOptions(onceOrOptions);\n    const idx = listeners.findIndex(([listener, lOptions]) => {\n      return listener === fn\n        && lOptions.once === options.once\n        && lOptions.signal === options.signal;\n    });\n    if (idx >= 0) {\n      listeners.splice(idx, 1);\n    }\n  };\n\n  const s = Object.assign(\n    function get() {\n      collectSignal(s);\n      return value;\n    },\n    {\n      destroy() {\n        listeners = [];\n      },\n      set,\n      reset() {\n        set(initialValue);\n      },\n      sub(fn, onceOrOptions) {\n        listeners.push([fn, formatSubOptions(onceOrOptions)]);\n        return () => unsub(fn, onceOrOptions);\n      },\n      unsub,\n      unsubAll() {\n        listeners = listeners.filter(l => l[1].signal);\n      },\n    } satisfies Pick<CurrentSignal, 'destroy' | 'set' | 'reset' | 'sub' | 'unsub' | 'unsubAll'>,\n  );\n\n  return s;\n}\n","import { signal, type Signal, type SignalOptions } from './signal.js';\n\nexport interface Computed<T> extends Omit<Signal<T>, 'set' | 'reset'> {\n  /**\n   * @returns An underlying signal value.\n   */\n  (): T;\n}\n\nconst collectContexts: Set<Signal<unknown>>[] = [];\n\nexport function collectSignal(signal: Signal<any>): void {\n  collectContexts.length && collectContexts[collectContexts.length - 1].add(signal);\n}\n\n/**\n * Creates a signal, which wil be automatically updated if some of its dependant signals were\n * modified.\n * @param fn - computation function.\n * @param options - additional functions.\n */\n// #__NO_SIDE_EFFECTS__\nexport function computed<T>(\n  fn: (prev?: T) => T,\n  options?: SignalOptions<T>,\n): Computed<T> {\n  let deps = new Set<Signal<unknown>>();\n\n  // An underlying signal.\n  let $signal: Signal<T> | undefined;\n\n  function s(): Signal<T> {\n    return $signal || ($signal = signal<T>(compute(), options));\n  }\n\n  function update() {\n    s().set(compute());\n  }\n\n  function compute(): T {\n    // As long as in this iteration, we may receive new signals as dependencies, we stop\n    // listening to the previous signals.\n    deps.forEach(s => {\n      s.unsub(update, { signal: true });\n    });\n\n    // Signals we collected during current computation.\n    const collectedSignals = new Set<Signal<unknown>>();\n    let result: T;\n\n    // Add this set to the global variable, so dependant signals will be catched.\n    collectContexts.push(collectedSignals);\n\n    try {\n      // Run the function and collect all called signals.\n      result = fn();\n    } finally {\n      // Remember to untrack the reactive context.\n      collectContexts.pop();\n    }\n\n    // Start tracking for all dependencies' changes and re-compute the computed value.\n    collectedSignals.forEach(s => {\n      s.sub(update, { signal: true });\n    });\n    deps = collectedSignals;\n\n    return result;\n  }\n\n  return Object.assign(function computed(): T {\n    return s()();\n  }, {\n    destroy() {\n      s().destroy();\n    },\n    sub(...args) {\n      return s().sub(...args);\n    },\n    unsub(...args) {\n      s().unsub(...args);\n    },\n    unsubAll(...args) {\n      s().unsubAll(...args);\n    },\n  } satisfies Pick<Computed<T>, 'destroy' | 'sub' | 'unsub' | 'unsubAll'>);\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}